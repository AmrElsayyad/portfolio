{
  "version": "https://jsonfeed.org/version/1",
  "title": "Stories by Amr ElSayyad on Medium",
  "home_page_url": "https://medium.com/@AmrElsayyad?source=rss-4c09ae6ec531------2",
  "description": "Stories by Amr ElSayyad on Medium",
  "author": {
    "name": "yourfriends@medium.com"
  },
  "items": [
    {
      "guid": "https://medium.com/p/0d614167d12b",
      "url": "https://medium.com/@AmrElsayyad/cqrs-vs-crud-choosing-the-right-pattern-for-your-application-0d614167d12b?source=rss-4c09ae6ec531------2",
      "title": "CQRS vs. CRUD: Choosing the Right Pattern for Your Application",
      "content_html": "<h4>Two Approaches, One Decision: Which Pattern is Best for Your System?</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*4pZggCxxLzRzG7w4iYXxyw.png\" /></figure><p>In the ever-evolving world of software development, the way your application interacts with data can make or break its success. Two design patterns, CRUD and CQRS, often stand at the crossroads of this decision, each offering a distinct approach to data management. But which one is the secret weapon your system needs? Whether you’re scaling a simple app or tackling a complex architecture, the choice between CRUD’s simplicity and CQRS’s strategic separation can dramatically impact your system’s performance and future-proofing.</p><h3>CQRS vs CRUD</h3><p>CQRS (Command Query Responsibility Segregation) and CRUD (Create, Read, Update, Delete) are two different patterns used in software development, particularly in managing how an application interacts with its data. To understand the difference between these two, let’s break them down using analogies and then dive into the technical details.</p><h4>CRUD: The Simple Storefront Clerk</h4><p>Imagine a small, simple storefront where there’s a single clerk who handles everything. This clerk manages all the tasks: helping customers place orders, checking inventory, updating product details, and deleting discontinued items. This is like the CRUD pattern:</p><ul><li><strong>Create:</strong> The clerk adds new products to the store.</li><li><strong>Read:</strong> The clerk checks the current inventory when a customer asks about a product.</li><li><strong>Update:</strong> The clerk changes the price of a product when necessary.</li><li><strong>Delete:</strong> The clerk removes a product that is no longer available.</li></ul><p>In a CRUD system, the same component (our clerk) is responsible for handling all these operations directly on the database. It’s straightforward and works well when the business is small and the operations are simple.</p><h4>CQRS: The Specialized Store</h4><p>Imagine a much larger and more complex store. This store has grown so much that the original clerk can’t handle everything efficiently. Instead, the store hires two specialists:</p><ol><li><strong>Command Specialist:</strong> This person only handles changes in the store—adding new products, updating prices, and removing items. They are like the <strong>Command</strong> part of CQRS.</li><li><strong>Query Specialist:</strong> This person is focused entirely on answering questions—checking inventory levels, reporting on sales figures, and so on. They are the <strong>Query</strong> part of CQRS.</li></ol><p>In this larger store, tasks are divided between these two specialists so that each can focus on their specific type of work. This division is the essence of the <strong>CQRS pattern</strong>:</p><ul><li><strong>Command:</strong> handles all changes to the system (Create, Update, Delete).</li><li><strong>Query:</strong> handles all data retrieval (Read).</li></ul><h3>Breaking Down the Details</h3><h4>CRUD in Detail</h4><p>CRUD is a monolithic approach where a single model or service handles all operations on data. Imagine a simple table in a database, like a spreadsheet. Each row is a record, and the operations you can perform on this table are Create (adding a new row), Read (viewing rows), Update (modifying a row), and Delete (removing a row).</p><p>In CRUD, every operation directly affects the data in the same place and often uses the same structure. It’s like directly editing the cells in the spreadsheet. This approach works well in simple systems, but as the system scales, it can become inefficient. Every time you need to update or read data, you have to work with the same model, which can slow things down if the data becomes large or complex.</p><h4>CQRS in Detail</h4><p>CQRS, on the other hand, suggests separating the concerns of data modification and data reading. The idea is that the operations that modify data (commands) and the operations that read data (queries) are fundamentally different and should be handled by different models or even different systems.</p><ol><li><strong>Command Side:</strong><br> — This side is responsible for processing all the changes in the data. It handles commands like “AddProduct,” “UpdatePrice,” or “RemoveItem.”<br> — Commands do not return data; they simply execute an action.</li><li><strong>Query Side:</strong><br> — This side is optimized for reading data. It handles queries like “GetProductDetails” or “ListAvailableProducts.”<br> — Queries can return detailed data in various formats, optimized for specific use cases.</li></ol><p>By separating these concerns, CQRS allows each side to scale independently and be optimized for its specific tasks. For example, the Command side can be optimized for processing changes quickly, while the Query side can be optimized for fast data retrieval.</p><h3>Technical Differences</h3><ul><li><strong>Data Models:</strong> In CRUD, there’s typically a single data model that handles both reads and writes. In CQRS, you might have two different models: one for writing data (commands) and another for reading data (queries). These models can even be stored in different databases optimized for their specific tasks.</li><li><strong>Scalability:</strong> CRUD can become a bottleneck as the system grows because the same resources are used for both reading and writing. CQRS can handle more complex systems more efficiently because the read and write workloads are separated.</li><li><strong>Consistency:</strong> In CRUD, data consistency is straightforward because everything happens in one place. In CQRS, especially when using different data models or databases, you might deal with eventual consistency, where the Query side may not immediately reflect the latest changes made on the Command side.</li><li><strong>Flexibility:</strong> CQRS is more flexible and can adapt to complex requirements. For instance, you can implement different security measures or validation rules for commands versus queries, something that’s harder to do in a CRUD-based system.</li></ul><h3>When to Use Each</h3><ul><li><strong>CRUD:</strong> Best for simple applications or where the operations on data are straightforward and don’t require high scalability or complex querying.</li><li><strong>CQRS:</strong> Ideal for complex, large-scale systems where read and write operations have different performance or scalability requirements. It’s also useful when the system needs to handle complex business logic or when you want to separate concerns for easier maintenance.</li></ul><h3>Summary</h3><ul><li><strong>CRUD</strong> is like a simple storefront clerk handling all tasks with a single system model—easy to implement and manage for straightforward applications.</li><li><strong>CQRS</strong> is like a specialized store where responsibilities are divided between command and query specialists, each optimized for different tasks, leading to better scalability, flexibility, and efficiency in complex systems.</li></ul><h3>Conclusion:</h3><p>Choosing between CRUD and CQRS depends on the specific needs of your application. CRUD is ideal for simpler, smaller systems where operations on data are straightforward. On the other hand, CQRS shines in complex, large-scale applications where scalability, performance, and flexibility are critical. By understanding the strengths and limitations of each pattern, you can make an informed decision that ensures your system is not only functional but also efficient and maintainable in the long run.</p><p>If you want to ask any questions, please leave them in the comments, and if you like the article, please clap from 1 to 50, depending on how much you like it, and follow me for more content like this.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=0d614167d12b\" width=\"1\" height=\"1\" alt=\"\">",
      "date_published": "2024-08-20T10:10:31.000Z",
      "author": {
        "name": "Amr ElSayyad"
      }
    },
    {
      "guid": "https://medium.com/p/f9d0306bd783",
      "url": "https://medium.com/@AmrElsayyad/the-art-of-clean-code-writing-software-that-stands-the-test-of-time-f9d0306bd783?source=rss-4c09ae6ec531------2",
      "title": "The Art of Clean Code: Writing Software That Stands the Test of Time",
      "content_html": "<h4>Writing code that works is just the beginning. You need to write maintainable and scalable code that is easily understood by others, including your future self.</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*wR6tkZIvM7bLWM3T\" /></figure><h3>What is Clean Code?</h3><p>At its core, clean code is all about readability and maintainability. It’s the kind of code that’s a breeze to understand, modify, and test. It’s straightforward in its goals and avoids unnecessary complexity and any cryptic tricks. As <em>Robert C. Martin</em>, author of <em>Clean Code</em>, said, “Clean code always appears as if it was written by someone who cares.”</p><h3>Key Principles of Clean Code</h3><p><strong>1. Meaningful Names:</strong> Use clear, descriptive names for variables, functions, and classes. A well-named function or variable should tell you what it does or what it represents without needing a comment.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*287fn5usqsA67eUBzAEIjQ.png\" /></figure><p><strong>2. Small Functions:</strong> Keep your functions short and focused. Each function should do one thing and do it well. This makes your code easier to understand, test, and reuse.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*XQPcPVLe7akYYZ6SkXH3XA.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*33rnCcKSnVeEYIC6xmmYIQ.png\" /></figure><p><strong>3. DRY (Don’t Repeat Yourself):</strong> Avoid duplicating code. If you find yourself writing the same logic in multiple places, it’s time to abstract that logic into a reusable function or class.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*U3hRvwUqwfMuBFSHvOnOpA.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*_WfwmyEyuLdWysWp4-ClvA.png\" /></figure><p><strong>4. SOLID Principles:</strong> Follow the SOLID principles of object-oriented design:<br>- Single Responsibility Principle<br>- Open-Closed Principle<br>- Liskov Substitution Principle<br>- Interface Segregation Principle<br>- Dependency Inversion Principle</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*nWPK98Re5W7uTS9UJls29A.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Bf8ZEvPs3T2_AyIrkT78pA.png\" /></figure><p><strong>5. Comments:</strong> Use comments sparingly and only when necessary. Good code should be self-explanatory. If you need a comment to explain what your code does, consider refactoring the code to make it clearer.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*eK-wAYG77C46b14F-dOd2Q.png\" /></figure><p><strong>6. Formatting:</strong> Consistent formatting is crucial for maintaining readability and manageability in a codebase, especially in a collaborative environment. Tools like clang-format for <strong>C</strong>, google-java-format for <strong>Java</strong>, black for <strong>Python</strong>, or Prettier for <strong>JavaScript</strong> can automate this process, ensuring uniformity throughout the project.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*IiSUbRGVWVG-0ESm8m7mCA.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*RJ3_vcgYkHfi7prZSn6ZuQ.png\" /></figure><p><strong>7. Error Handling:</strong> Graceful error handling and clear error messages are key to debugging and sustaining a healthy codebase. It’s essential for a program to manage unforeseen events smoothly without crashing, while also offering valuable insights for troubleshooting problems.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Srgst45WLyywtuFYyenOAg.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*CbiDiIfcllMnJfsvZ2JODw.png\" /></figure><p><strong>8. Unit Tests:</strong> Tests not only catch bugs early but also serve as documentation for how your code should behave. This also provides the assurance needed to refactor code with the confidence that these changes will not disrupt existing functionalities.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ZXteWQPMnBYtvSyy492m5Q.png\" /></figure><h3>Benefits of Clean Code</h3><ol><li><strong>Improved Maintainability:</strong> Clean code is easier to maintain and modify, reducing the cost of changes over time.</li><li><strong>Better Collaboration:</strong> When code is clean and clear, it’s easier for team members to understand and contribute to each other’s work.</li><li><strong>Fewer Bugs:</strong> Clean code tends to have fewer bugs because its simplicity leaves less room for errors to hide.</li><li><strong>Faster Development:</strong> While writing clean code might take a bit more time upfront, it pays off in faster development speeds as your project grows.</li><li><strong>Easier Onboarding:</strong> New team members can get up to speed more quickly when working with clean, well-structured code.</li></ol><h3>Conclusion</h3><p>Writing clean code is not just a technical skill — it’s a mindset. It’s about taking pride in your craft and considering the impact of your work on others. By consistently applying the principles of clean code, you can create software that not only works but also stands the test of time. Remember, code is read far more often than it is written, so always strive to write code that reads like well-written prose.</p><p>Start your journey towards cleaner code today, and watch as it transforms not just your software but your entire approach to problem-solving in development.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f9d0306bd783\" width=\"1\" height=\"1\" alt=\"\">",
      "date_published": "2024-06-22T13:47:13.000Z",
      "author": {
        "name": "Amr ElSayyad"
      }
    },
    {
      "guid": "https://medium.com/p/386ba91f5f38",
      "url": "https://medium.com/@AmrElsayyad/mastering-data-visualization-the-ultimate-guide-to-choosing-the-right-plot-for-your-data-386ba91f5f38?source=rss-4c09ae6ec531------2",
      "title": "Mastering Data Visualization: The Ultimate Guide to Choosing the Right Plot for Your Data",
      "content_html": "<h4>A plot tells a thousand words, they say.</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*ZKUsqB2IKLwa_g7B\" /></figure><p>Visualizing data is very helpful in drawing conclusions and insights from it. There are so many different types of plots that choosing the right one might be tricky.</p><p>Don’t know which type of plot best represents your data? Here’s a summary of the best types of plots for each type of dataset.</p><h3>Histograms</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/491/0*tMGqmeW-2S9vsih8\" /></figure><p>A histogram is the best way to display the distribution of a continuous variable, i.e., when you have a continuous variable like age and the data shows the number of occurrences of that variable, like the number of rulers of England that started ruling at a particular age, a histogram can show you the number of rulers for each age group.</p><h3>Rose Plots</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/344/0*IUbpagGiHHdhRsT1\" /></figure><p>Rose Plots are a special type of histogram. They are used to display the distribution of data of cyclical nature. Cyclical data are data whose range starts and ends at the same point, e.g., time of day or compass direction. The plot shown represents the activity hours for some types of rodents. You can see that the longer the radius of a portion, the more active this type of rodent is at this hour of the day.</p><h3>Box Plots</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/502/0*PGRsAzgRPZ7N4TEA\" /></figure><p>Box Plots are the best way to display the distribution of a single continuous variable that needs to be plotted against a categorical variable. For example, comparing the age (continuous variable) at which a ruler of England started ruling for each royal house (categorical variable). The best thing about box plots is that, unlike histograms, they can show us multiple features of data at once, e.g., median, min, max, and interquartile range (IQR).</p><h4>But what is a boxplot in the first place?</h4><p>A box plot is a graphical representation where the central line of the box indicates the median value. The box itself is defined by the upper and lower quartile limits, meaning it encompasses the middle half of the data. The lines extending from the box, known as whiskers, denote the upper and lower quartiles. Essentially, the data is split into four quartiles: the second and third quartiles are contained within the box with the median marked in the center, while the first and fourth quartiles extend as whiskers. The box delineates the normal value range, the whiskers show the full range of values, and any points beyond the whiskers are considered outliers, indicating extreme values.</p><h3>Scatter Plots</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/502/0*BeRoQ6a_NYN5bDHB\" /></figure><p>Scatter Plots are used to show the relationship of two numerical variables. For example, the plot shown compares the price of residential properties in one state in the US and their area, which shows a direct relationship between the two.</p><h3>Bar Plots</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/396/0*1vWbWeigS45WWwTu\" /></figure><p>Bar plots are the best way to describe labels’ counts of a categorical variable. For the example shown, the plot shows the number of players per country that are on the ESPN Top 100 list. Bar Plots can be vertical or horizontal. The choice of a horizontal one here is so the y-axis label can be readable.</p><h3>Dot Plots</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/307/0*fvwxLFbPPOI8R6-B\" /></figure><p>Dot Plots are much like bar plots, but instead of showing one metric of a variable, e.g. count, they can show multiple features. One advantage of using dot plots is that they don’t refer to zero, enabling us to take the logarithmic scale of the variables we plot. In the plot shown, you can see the number of followers of each player on Facebook, Instagram, and Twitter, represented by different dot colors. Also, you will find players grouped by sport and sorted by player name.</p><h3>Line Plots</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/517/0*JqaQ1hKBI_eT2Gxv\" /></figure><p>Line plots are the best way to display trends over time. In the plot shown, the number of confirmed cases in China and the rest of the world is plotted against time, which shows how the number of cases is changing over the time period of February and March 2020 and compares the numbers between China and the rest of the world using different colors.</p><h3>What if you need to add more variables to your plot?</h3><p>Well, you can use size, transparency, shape, or line weight, but these options often make the plot harder to interpret. Using colors and multiple panels is often the best way to add more dimensions to your plot.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/744/0*slUTf-NPt4vFrBQW\" /></figure><h3>Types of Color Scale</h3><p>Using color may be the best way to add more variables to your plot. There are three different ways to use color for different situations:</p><h4>Qualitative</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/377/0*bK12i93dIECdTFNe\" /></figure><p>Using different colors to distinguish between different categories. The plot shown compares the adoption percentage of four different technologies over the time period of 1930 to 1970.</p><h4>Sequential</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/383/0*UleQqh3J-fR87jQQ\" /></figure><p>Using different gradients of the same color to display multiple ranges of a continuous variable. The plot shown here displays the percentage of children eating a particular number of veggies per day from 2001 to 2018. Here you can see the number of veggies per day divided into portions. Each portion has a gradient of the same color; the darker the color, the more portions children eat per day.</p><h4>Diverging</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/316/0*Mo9ZVRqsAG_eFYY_\" /></figure><p>Imagine a scale that visually represents survey data with two colors: blue and red. Each side of the scale uses a gradient that fades into a neutral hue at the center, effectively illustrating values above or below a central point. In this survey plot, the varying shades of blue and red correspond to the percentage of respondents who agree or disagree, providing a clear and impactful way to interpret the data.</p><h3>3 Plots for Comparing Many Variables</h3><p>Sometimes, you need to compare a larger number of variables. Here are 3 plots for this case:</p><h3>Pair Plots</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/458/0*8AA_Ne7SiiylCVoL\" /></figure><p>Pair plots are incredibly useful when you need to compare up to 10 variables to understand the distribution of each and the relationships between them. The diagonal panels reveal the distribution of individual variables, with bar plots for categorical and histograms for continuous variables. The off-diagonal panels, on the other hand, display the relationships between variable pairs. Here, you’ll find scatter plots and correlation coefficients for continuous variables, and for a mix of categorical and continuous variables, histograms and box plots segmented by category.</p><h3>Correlation Heatmaps</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/438/0*Kc4byCDoinayllqP\" /></figure><p>Correlation Heatmaps are useful for showing the correlation between many continuous variables. The stronger the correlation, the darker the color. Due to the compatibility of the heatmap, it can be used to display 10’s of variables.</p><h3>Parallel Coordinates Plot</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/589/0*nVYYAY8rNJ_Hclas\" /></figure><p>A parallel coordinates plot can be very useful when trying to find patterns between multiple continuous variables or group them into clusters. Here you can easily see the range for each continuous variable, and you can see which has more consistency. You can also see which variable has high values and which has low values.</p><h3>Conclusion</h3><p>Plots are very helpful when trying to understand your data. Bad plots can result in inaccurate conclusions. Choosing which type of plot is suitable for your data is very important. Hopefully, this article will help you distinguish between different types of plots, and which one to choose for each situation. If this article was helpful, please let me know.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=386ba91f5f38\" width=\"1\" height=\"1\" alt=\"\">",
      "date_published": "2024-06-21T16:09:38.000Z",
      "author": {
        "name": "Amr ElSayyad"
      }
    }
  ]
}